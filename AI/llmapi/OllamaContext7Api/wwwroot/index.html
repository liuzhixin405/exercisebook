<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 助手</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background-color: #f4f4f4;
        }
        #file-management-container {
            width: 30%; /* 30% width for file management */
            padding: 15px;
            border-right: 1px solid #ccc;
            background-color: #fff;
            overflow-y: auto; /* Scroll for file list */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #chat-container {
            flex-grow: 1; /* Takes remaining width */
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            background-color: #e9e9e9;
        }
        h2, h3 {
            color: #333;
            margin-top: 0;
        }
        #response {
            flex-grow: 1;
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            overflow-y: auto;
            background-color: #fff;
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
        }
        .input-group {
            display: flex;
            margin-bottom: 10px;
        }
        #questionInput {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical; /* Allow vertical resizing */
            min-height: 70px; /* Minimum height for 3 lines of text */
            box-sizing: border-box;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        button {
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #loading {
            margin-top: 10px;
            color: #007bff;
            display: none;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border: 1px solid #eee;
            margin-bottom: 5px;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .file-item.selected {
            background-color: #d0e7ff;
            border-color: #007bff;
        }
        .file-item button {
            padding: 5px 10px;
            background-color: #dc3545;
            font-size: 12px;
        }
        .file-item button:hover {
            background-color: #c82333;
        }
        #file-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            flex-grow: 1; /* Allow file list to expand */
            overflow-y: auto; /* Scroll for file list */
        }
        .file-list-item {
            display: flex;
            align-items: center;
            padding: 5px 0;
            cursor: pointer;
        }
        .file-list-item.selected {
            background-color: #e0e0e0;
        }
        .file-list-item input[type="checkbox"] {
            margin-right: 5px;
        }
        .file-list-item .folder-icon {
            margin-right: 5px;
            color: #ffc107; /* Folder icon color */
        }
        .file-list-item .file-icon {
            margin-right: 5px;
            color: #6c757d; /* File icon color */
        }
        #project-info {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        #project-path {
            font-weight: bold;
            word-break: break-all;
        }
        .file-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .folder-navigation {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        #goUpBtn {
            padding: 5px 10px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        #goUpBtn:hover {
            background-color: #5a6268;
        }
        .upload-button-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .upload-button-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="file-management-container">
        <h2>文件管理</h2>
        <div id="project-info">
            当前项目路径: <span id="project-path"></span>
        </div>
        <div class="folder-navigation">
            <button id="goUpBtn">返回上级</button>
            <button onclick="createNewFolder()">新建文件夹</button>
        </div>
        <div class="file-actions">
            <button onclick="createNewProject()">新建项目</button>
            <div class="upload-button-wrapper">
                <button>选择文件夹</button>
                <input type="file" id="fileInput" webkitdirectory directory multiple onchange="handleFileSelection(event)">
            </div>
            <button onclick="uploadFiles()">上传到当前项目</button>
        </div>
        <ul id="file-list"></ul>
        <button onclick="deleteAllFiles()">移除当前项目所有文件</button>
    </div>
    <div id="chat-container">
        <h2>AI 聊天</h2>
        <div id="response">等待提问...</div>
        <div id="loading">思考中...</div>
        <div class="input-group">
            <textarea id="questionInput" placeholder="请输入你的问题..."></textarea>
        </div>
        <div class="button-group">
            <button id="askBtn">提问</button>
            <button id="stopBtn">停止</button>
            <button id="clearBtn">清空</button>
            <button id="healthBtn">健康检查</button>
            <input type="checkbox" id="deepModeCheckbox"> <label for="deepModeCheckbox">深度模式</label>
        </div>
    </div>

    <script>
        console.log("Script loaded and starting initialization."); // Added a very early log

        let eventSource = null; // No longer used for main streaming, but kept for clarity if needed elsewhere
        let isStreaming = false;
        let selectedFiles = new Set(); // Stores full paths of selected files
        let currentProjectPath = ''; // Stores the current project path, relative to the backend's base path
        let globalFileTree = {}; // Stores the entire file tree for the current project
        let currentReader = null; // Store the reader to abort it on stopStream

        async function createNewProject() {
            console.log("createNewProject called");
            const projectName = prompt("请输入新项目的名称:");
            if (projectName) {
                try {
                    const response = await fetch(`/api/file/create-folder`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ folderName: projectName })
                    });
                    if (response.ok) {
                        alert(`项目 \"${projectName}\" 创建成功！`);
                        currentProjectPath = projectName; // Set current project to the newly created one
                        await listFiles(currentProjectPath); // List files in the new project
                    } else {
                        const errorText = await response.text();
                        alert(`创建项目失败: ${errorText}`);
                    }
                } catch (error) {
                    console.error('创建项目时出错:', error);
                    alert('创建项目时发生网络错误。');
                }
            }
        }

        async function createNewFolder() {
            console.log("createNewFolder called");
            const folderName = prompt("请输入新文件夹的名称:");
            if (folderName) {
                const fullPath = currentProjectPath ? `${currentProjectPath}/${folderName}` : folderName;
                try {
                    const response = await fetch(`/api/file/create-folder`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ folderName: fullPath })
                    });
                    if (response.ok) {
                        alert(`文件夹 \"${fullPath}\" 创建成功！`);
                        await listFiles(currentProjectPath); // Refresh current directory
                    } else {
                        const errorText = await response.text();
                        alert(`创建文件夹失败: ${errorText}`);
                    }
                } catch (error) {
                    console.error('创建文件夹时出错:', error);
                    alert('创建文件夹时发生网络错误。');
                }
            }
        }

        function handleFileSelection(event) {
            console.log("handleFileSelection called");
            const files = event.target.files;
            if (files.length > 0) {
                console.log("Selected files:", files);
                // No need to display files here, they will be uploaded
            }
        }

        async function uploadFiles() {
            console.log("uploadFiles called");
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;

            if (files.length === 0) {
                alert('请选择要上传的文件或文件夹。');
                return;
            }

            const formData = new FormData();
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                // Calculate relative path for each file within the selected folder structure
                const relativePath = file.webkitRelativePath || file.name;
                const uploadPath = currentProjectPath ? `${currentProjectPath}/${relativePath}` : relativePath;
                formData.append('files', file, uploadPath);
            }

            try {
                const response = await fetch('/api/file/upload', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    alert('文件上传成功！');
                    fileInput.value = ''; // Clear selected files
                    await listFiles(currentProjectPath); // Refresh file list
                } else {
                    const errorText = await response.text();
                    alert(`文件上传失败: ${errorText}`);
                }
            } catch (error) {
                console.error('上传文件时出错:', error);
                alert('上传文件时发生网络错误。');
            }
        }

        async function listFiles(path = '') {
            console.log("listFiles called with path:", path);
            document.getElementById('project-path').textContent = path || '根目录';
            currentProjectPath = path;

            try {
                const response = await fetch(`/api/file/list?path=${encodeURIComponent(path)}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                globalFileTree = await response.json(); // Store the entire tree (which is now a FileExplorerItem)
                renderFileTree(globalFileTree, document.getElementById('file-list'), path);

                const goUpBtn = document.getElementById('goUpBtn');
                if (goUpBtn) { // Add null check
                    goUpBtn.disabled = !path; // Disable if at root
                } else {
                    console.warn("goUpBtn not found."); // Log if button not found
                }

            } catch (error) {
                console.error('加载文件失败:', error);
                alert('加载文件失败: ' + error.message);
            }
        }

        function renderFileTree(tree, parentElement, currentPath) {
            console.log("renderFileTree called");
            parentElement.innerHTML = '';
            // Ensure tree.children is an array before sorting and iterating
            if (!tree || !Array.isArray(tree.children)) {
                console.warn("Invalid file tree structure or empty children.", tree);
                return; // Exit if children is not an array
            }
            tree.children.sort((a, b) => {
                if (a.type === 'directory' && b.type !== 'directory') return -1;
                if (a.type !== 'directory' && b.type === 'directory') return 1;
                return a.name.localeCompare(b.name);
            }).forEach(item => {
                const li = document.createElement('li');
                li.className = 'file-list-item';
                const fullPath = currentPath ? `${currentPath}/${item.name}` : item.name;

                if (item.type === 'directory') {
                    li.innerHTML = `<span class=\"folder-icon\">&#128193;</span> ${item.name}`;
                    li.onclick = () => listFiles(fullPath); // Navigate into folder
                } else {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = selectedFiles.has(fullPath);
                    checkbox.onchange = (e) => {
                        e.stopPropagation(); // Prevent li click from interfering
                        toggleFileSelection(fullPath, checkbox.checked);
                    };
                    li.appendChild(checkbox);
                    li.innerHTML += `<span class=\"file-icon\">&#128196;</span> ${item.name}`;
                    li.onclick = () => toggleFileSelection(fullPath, !checkbox.checked);
                    li.insertBefore(checkbox, li.firstChild); // Ensure checkbox is first child
                }
                parentElement.appendChild(li);
            });
        }

        function toggleFileSelection(filePath, isSelected) {
            console.log("toggleFileSelection called");
            if (isSelected) {
                selectedFiles.add(filePath);
            } else {
                selectedFiles.delete(filePath);
            }
            // Re-render the file tree to update checkbox states
            renderFileTree(globalFileTree, document.getElementById('file-list'), currentProjectPath);
            console.log("Selected files:", Array.from(selectedFiles));
        }

        async function deleteAllFiles() {
            console.log("deleteAllFiles called");
            if (!confirm(`确定要移除当前项目 \"${currentProjectPath || '根目录'}\" 下的所有文件吗？这将不可逆！`)) {
                return;
            }

            try {
                const response = await fetch(`/api/file/delete-all?path=${encodeURIComponent(currentProjectPath)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    alert('所有文件已移除！');
                    selectedFiles.clear(); // Clear selected files
                    await listFiles(currentProjectPath); // Refresh file list
                } else {
                    const errorText = await response.text();
                    alert(`移除文件失败: ${errorText}`);
                }
            } catch (error) {
                console.error('移除文件时出错:', error);
                alert('移除文件时发生网络错误。');
            }
        }

        async function askQuestionStream() {
            console.log("askQuestionStream called");
            if (isStreaming) return;

            const question = document.getElementById('questionInput').value;
            const deepMode = document.getElementById('deepModeCheckbox').checked;
            const responseDiv = document.getElementById('response');
            setLoading(true);
            responseDiv.textContent = ''; // Clear previous response

            try {
                const relatedFiles = Array.from(selectedFiles); // Get full paths of selected files

                const response = await fetch('/api/question/ask-stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question: question,
                        relatedFiles: relatedFiles,
                        isDeepMode: deepMode
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                isStreaming = true;
                setButtonStates(true);

                currentReader = response.body?.getReader();
                if (!currentReader) {
                    throw new Error("无法获取响应流。");
                }
                const decoder = new TextDecoder('utf-8');
                let buffer = '';

                while (true) {
                    const { done, value } = await currentReader.read();
                    if (done) {
                        console.log("Stream complete.");
                        break;
                    }

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete SSE messages
                    let newlineIndex;
                    while ((newlineIndex = buffer.indexOf('\n\n')) !== -1) {
                        const message = buffer.substring(0, newlineIndex);
                        buffer = buffer.substring(newlineIndex + 2);

                        if (message.startsWith('event:')) {
                            const eventTypeMatch = message.match(/^event: (.*)/m);
                            const dataMatch = message.match(/^data: (.*)/m);

                            if (eventTypeMatch && dataMatch) {
                                const eventType = eventTypeMatch[1].trim();
                                const jsonData = dataMatch[1].trim();

                                try {
                                    const parsedData = JSON.parse(jsonData);
                                    if (eventType === 'data' && parsedData.content) {
                                        responseDiv.textContent += parsedData.content;
                                        responseDiv.scrollTop = responseDiv.scrollHeight; // Auto-scroll to bottom
                                    } else if (eventType === 'error' && parsedData.error) {
                                        console.error("Server-side error:", parsedData.error, parsedData.message);
                                        responseDiv.textContent += `\n\n[服务器错误: ${parsedData.message || parsedData.error}]`;
                                        stopStreaming();
                                    } else if (eventType === 'end') {
                                        console.log("Received end event.");
                                        stopStreaming();
                                        return; // Exit after end event
                                    }
                                } catch (jsonParseError) {
                                    console.error("Error parsing SSE data JSON:", jsonParseError, jsonData);
                                }
                            }
                        }
                    }
                }

            } catch (error) {
                console.error('发起流式提问时出错:', error);
                responseDiv.textContent = `\n\n[连接中断或发生错误: ${error.message}]`;
                stopStreaming();
            }
        }

        function stopStream() {
            console.log("stopStream called");
            if (currentReader) {
                currentReader.cancel("User stopped stream").catch(error => console.warn("Failed to cancel reader:", error));
                currentReader = null;
            }
            fetch('/api/question/stop-stream', { method: 'POST' })
                .then(response => {
                    if (response.ok) {
                        console.log('流式传输停止请求已发送。');
                    } else {
                        console.error('停止流式传输失败。');
                    }
                })
                .catch(error => {
                    console.error('停止流式传输时出错:', error);
                });
            stopStreaming(); // Also call stopStreaming to update UI and internal state
        }

        function stopStreaming() {
            console.log("stopStreaming called");
            // No eventSource.close() anymore, rely on reader.cancel()
            isStreaming = false;
            setLoading(false);
            setButtonStates(false);
        }

        function clearResponse() {
            console.log("clearResponse called");
            document.getElementById('response').textContent = '等待提问...';
        }

        async function checkHealth() {
            console.log("checkHealth called");
            try {
                const deepMode = document.getElementById('deepModeCheckbox').checked;
                const response = await fetch(`/api/question/health?isDeepMode=${deepMode}`);
                const data = await response.text();
                alert('健康检查结果: ' + data);
            } catch (error) {
                console.error('健康检查失败:', error);
                alert('健康检查失败: 无法连接到后端服务或服务异常。');
            }
        }

        function setLoading(isLoading) {
            console.log("setLoading called with", isLoading);
            document.getElementById('loading').style.display = isLoading ? 'block' : 'none';
        }

        function setButtonStates(streaming) {
            console.log("setButtonStates called with", streaming);
            document.getElementById('askBtn').disabled = streaming;
            document.getElementById('stopBtn').disabled = !streaming;
            document.getElementById('clearBtn').disabled = streaming;
            document.getElementById('healthBtn').disabled = streaming;
        }

        document.getElementById('goUpBtn').addEventListener('click', () => {
            console.log("goUpBtn clicked");
            const pathParts = currentProjectPath.split('/');
            if (pathParts.length > 1) {
                pathParts.pop();
                listFiles(pathParts.join('/'));
            } else {
                listFiles(''); // Go to root
            }
        });

        window.addEventListener('load', async () => {
            console.log("Window loaded. Initializing..."); // This is the early log
            setButtonStates(false); // Initialize button states
            
            // Assigning onclick handlers to buttons
            const askBtn = document.getElementById('askBtn');
            const stopBtn = document.getElementById('stopBtn');
            const clearBtn = document.getElementById('clearBtn');
            const healthBtn = document.getElementById('healthBtn');

            if (askBtn) askBtn.onclick = askQuestionStream;
            else console.error("askBtn not found!");
            
            if (stopBtn) stopBtn.onclick = stopStream;
            else console.error("stopBtn not found!");

            if (clearBtn) clearBtn.onclick = clearResponse;
            else console.error("clearBtn not found!");

            if (healthBtn) healthBtn.onclick = checkHealth;
            else console.error("healthBtn not found!");

            // Ensure deepModeCheckbox is unchecked by default
            const deepModeCheckbox = document.getElementById('deepModeCheckbox');
            if (deepModeCheckbox) {
                deepModeCheckbox.checked = false;
            } else {
                console.error("deepModeCheckbox not found!");
            }

            // Attempt to create 'document' directory if currentProjectPath is empty
            if (!currentProjectPath) {
                try {
                    const response = await fetch('/api/file/create-folder', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ folderName: 'document' })
                    });
                    if (response.ok) {
                        console.log("默认目录 'document' 已创建或已存在。");
                        await listFiles('document');
                    } else {
                        const errorText = await response.text();
                        console.warn(`创建默认目录 'document' 失败: ${errorText}`);
                        await listFiles(''); // Fallback to root if creation fails
                    }
                } catch (error) {
                    console.error('尝试创建默认目录时出错:', error);
                    await listFiles(''); // Fallback to root on network error
                }
            }
        });
    </script>
</body>
</html>
