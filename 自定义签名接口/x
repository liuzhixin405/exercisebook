namespace AutoMapper
{
    /// <summary>
    /// 自动映射辅助类
    /// </summary>
    public static class AutoMapperUtil
    {
        /// <summary>
        /// 自动映射配置
        /// </summary>
        private static MapperConfiguration mapperConfiguration;

        /// <summary>
        /// 同步映射
        /// </summary>
        private readonly static object syncMapper = new object();

        /// <summary>
        /// 映射
        /// </summary>
        private static Mapper mapper;

        /// <summary>
        /// 映射
        /// </summary>
        public static Mapper Mapper
        {
            get
            {
                if (mapper == null)
                {
                    lock (syncMapper)
                    {
                        if (mapper == null)
                        {
                            mapper = new Mapper(mapperConfiguration);
                        }
                    }
                }

                return mapper;
            }
        }

        /// <summary>
        /// 配置列表
        /// </summary>
        private readonly static IList<Action<IMapperConfigurationExpression>> configs = new List<Action<IMapperConfigurationExpression>>();

        /// <summary>
        /// 自动映射配置列表
        /// </summary>
        private readonly static IList<IAutoMapperConfig> mapperConfigs = new List<IAutoMapperConfig>();

        /// <summary>
        /// 注册配置
        /// </summary>
        /// <param name="config">配置回调</param>
        public static void RegisterConfig(Action<IMapperConfigurationExpression> config)
        {
            configs.Add(config);
        }

        /// <summary>
        /// 自动找出实现IAutoMapperConfig接口的配置
        /// </summary>
        /// <param name="assemblyNames">程序集名数组</param>
        public static void AutoRegisterConfig(string[] assemblyNames)
        {
            if (assemblyNames.IsNullOrEmpty())
            {
                return;
            }

            var assemblies = new Assembly[assemblyNames.Length];
            for (var i = 0; i < assemblies.Length; i++)
            {
                assemblies[i] = Assembly.Load(assemblyNames[i]);
            }

            AutoRegisterConfig(assemblies);
        }

        /// <summary>
        /// 自动找出实现IAutoMapperConfig接口的配置
        /// </summary>
        /// <param name="assemblies">程序集数组</param>
        public static void AutoRegisterConfig(Assembly[] assemblies)
        {
            var types = ReflectExtensions.GetImplClassType(assemblies, typeof(IAutoMapperConfig));
            if (types.IsNullOrEmpty())
            {
                return;
            }

            foreach (var t in types)
            {
                var config = t.Assembly.CreateInstance(t.FullName) as IAutoMapperConfig;
                mapperConfigs.Add(config);
            }
        }

        /// <summary>
        /// 生成映射配置
        /// 会循环生成注册的配置
        /// 程序启动时执行，只需执行一次
        /// 如果已经生成过，则会忽略
        /// </summary>
        public static void Builder()
        {
            if (mapperConfiguration != null)
            {
                return;
            }

            mapperConfiguration = new MapperConfiguration(config =>
            {
                foreach (var m in mapperConfigs)
                {
                    m.Register(config);
                }

                foreach (var c in configs)
                {
                    c(config);
                }
            });
        }
    }
}
using AutoMapper;
using Castle.DynamicProxy;

namespace Microsoft.Extensions.DependencyInjection
{
    /// <summary>
    /// 注册程序集扩展类
    /// </summary>
    public static class RegisterAssemblyExtensions
    {
        /// <summary>
        /// 用DI批量注入接口程序集中对应的实现类
        /// </summary>
        /// <param name="service">服务收藏</param>
        /// <param name="interfaceAssemblyName">接口程序集的名称（不包含文件扩展名）</param>
        /// <param name="implementAssemblyName">实现程序集的名称（不包含文件扩展名）</param>
        /// <param name="lifecycle">生命周期，默认为瞬时</param>
        /// <param name="interceptedClasses">拦截器类型字典，key：拦截器，value：生命周期</param>
        /// <param name="interfacTypeCallback">接口类型回调，key：接口类型；value：是否忽略</param>
        /// <returns>服务收藏</returns>
        public static IServiceCollection RegisterAssembly(this IServiceCollection service, string interfaceAssemblyName, string implementAssemblyName, 
            ServiceLifetime lifecycle = ServiceLifetime.Transient, IDictionary<Type, ServiceLifetime> interceptedClasses = null, Func<Type, bool> interfacTypeCallback = null)
        {            
            if (service == null)
            {
                throw new ArgumentNullException(nameof(service));
            }
            if (string.IsNullOrEmpty(interfaceAssemblyName))
            {
                throw new ArgumentNullException(nameof(interfaceAssemblyName));
            }
            if (string.IsNullOrEmpty(implementAssemblyName))
            {
                throw new ArgumentNullException(nameof(implementAssemblyName));
            }

            var interfaceAssembly = Assembly.Load(interfaceAssemblyName);
            if (interfaceAssembly == null)
            {
                throw new DllNotFoundException($"the dll \"{interfaceAssemblyName}\" not be found");
            }

            var implementAssembly = Assembly.Load(implementAssemblyName);
            if (implementAssembly == null)
            {
                throw new DllNotFoundException($"the dll \"{implementAssemblyName}\" not be found");
            }

            AutoMapperUtil.AutoRegisterConfig(new Assembly[] { interfaceAssembly, implementAssembly });

            if (!interceptedClasses.IsNullOrEmpty())
            {
                service.AddSingleton<IProxyGenerator, ProxyGenerator>();
                service.AddTypeMapLifetimes(interceptedClasses);
            }

            //过滤掉非接口
            var types = interfaceAssembly.GetTypes().Where(t => t.GetTypeInfo().IsInterface);

            foreach (var type in types)
            {
                if (interfacTypeCallback != null && interfacTypeCallback(type))
                {
                    continue;
                }

                //过滤掉抽象类、以及非class
                var implementType = implementAssembly.DefinedTypes
                   .FirstOrDefault(t => t.IsClass && !t.IsAbstract && t.GetInterfaces().Any(b => b.Name == type.Name));
                if (implementType != null)
                {
                    var constrs = implementType.GetConstructors();
                    if (!constrs.IsNullOrEmpty() && !constrs.Any(p => p.IsPublic))
                    {
                        continue;
                    }

                    switch (lifecycle)
                    {
                        case ServiceLifetime.Transient:
                            if (interceptedClasses.IsNullOrEmpty())
                            {
                                service.AddTransient(type, implementType.AsType());
                            }
                            else
                            {
                                service.AddTransient(type, provider =>
                                {
                                    return provider.GetProxyInstanceFromProvider(implementType.AsType(), interceptedClasses == null ? null : interceptedClasses.Keys);
                                });
                            }

                            break;

                        case ServiceLifetime.Scoped:
                            if (interceptedClasses.IsNullOrEmpty())
                            {
                                service.AddScoped(type, implementType.AsType());
                            }
                            else
                            {
                                service.AddScoped(type, provider =>
                                {
                                    return provider.GetProxyInstanceFromProvider(implementType.AsType(), interceptedClasses == null ? null : interceptedClasses.Keys);
                                });
                            }

                            break;

                        case ServiceLifetime.Singleton:
                            if (interceptedClasses.IsNullOrEmpty())
                            {
                                service.AddSingleton(type, implementType.AsType());
                            }
                            else
                            {
                                service.AddSingleton(type, provider =>
                                {
                                    return provider.GetProxyInstanceFromProvider(implementType.AsType(), interceptedClasses == null ? null : interceptedClasses.Keys);
                                });
                            }

                            break;

                        default:
                            throw new NotSupportedException($"不支持的生命周期:{lifecycle}");
                    }
                }
            }

            return service;
        }

        /// <summary>
        /// 用DI批量注入批定接口类型的实现类程序集中的实现类
        /// </summary>
        /// <param name="service">服务收藏</param>
        /// <param name="interfaceType">接口类型</param>
        /// <param name="lifecycle">生命周期，默认为瞬时</param>
        /// <param name="interceptedClasses">拦截器类型字典，key：拦截器，value：生命周期</param>
        /// <param name="implClassAssemblys">接口程序集的名称（不包含文件扩展名）</param>
        /// <returns>服务收藏</returns>
        public static IServiceCollection RegisterAssemblyWithInterfaceMapImpls(this IServiceCollection service, Type interfaceType,
            ServiceLifetime lifecycle = ServiceLifetime.Transient, IDictionary<Type, ServiceLifetime> interceptedClasses = null,  params string[] implClassAssemblys)
        {
            if (service == null)
            {
                throw new ArgumentNullException(nameof(service));
            }
            if (implClassAssemblys.IsNullOrEmpty())
            {
                throw new ArgumentNullException(nameof(implClassAssemblys));
            }

            Assembly[] assemblies = new Assembly[implClassAssemblys.Length];
            for (var i = 0; i < implClassAssemblys.Length; i++)
            {
                assemblies[i] = Assembly.Load(implClassAssemblys[i]);
            }

            AutoMapperUtil.AutoRegisterConfig(assemblies);

            var implTypes = ReflectExtensions.GetImplClassType(assemblies, interfaceType);
            if (implTypes.IsNullOrEmpty())
            {
                return service;
            }

            if (!interceptedClasses.IsNullOrEmpty())
            {
                service.AddSingleton<IProxyGenerator, ProxyGenerator>();
                service.AddTypeMapLifetimes(interceptedClasses);
            }

            foreach (var it in implTypes)
            {
                if (it.IsAbstract)
                {
                    continue;
                }
                var constrs = it.GetConstructors();
                if (!constrs.IsNullOrEmpty() && !constrs.Any(p => p.IsPublic))
                {
                    continue;
                }

                switch (lifecycle)
                {
                    case ServiceLifetime.Transient:
                        if (interceptedClasses.IsNullOrEmpty())
                        {
                            service.AddTransient(interfaceType, it);
                        }
                        else
                        {
                            service.AddTransient(interfaceType, provider =>
                            {
                                return provider.GetProxyInstanceFromProvider(interfaceType, interceptedClasses == null ? null : interceptedClasses.Keys);
                            });
                        }

                        break;

                    case ServiceLifetime.Scoped:
                        if (interceptedClasses.IsNullOrEmpty())
                        {
                            service.AddScoped(interfaceType, it);
                        }
                        else
                        {
                            service.AddScoped(interfaceType, provider =>
                            {
                                return provider.GetProxyInstanceFromProvider(interfaceType, interceptedClasses == null ? null : interceptedClasses.Keys);
                            });
                        }

                        break;

                    case ServiceLifetime.Singleton:
                        if (interceptedClasses.IsNullOrEmpty())
                        {
                            service.AddSingleton(interfaceType, it);
                        }
                        else
                        {
                            service.AddSingleton(interfaceType, provider =>
                            {
                                return provider.GetProxyInstanceFromProvider(interfaceType, interceptedClasses == null ? null : interceptedClasses.Keys);
                            });
                        }

                        break;

                    default:
                        throw new NotSupportedException($"不支持的生命周期:{lifecycle}");
                }
            }

            return service;
        }

        /// <summary>
        /// 从服务提供者获取代理实例
        /// </summary>
        /// <param name="provider">服务提供者</param>
        /// <param name="type">类型</param>
        /// <param name="interceptedClasses">拦截器类型字典集合</param>
        /// <returns>代理实例</returns>
        public static object GetProxyInstanceFromProvider(this IServiceProvider provider, Type type, ICollection<Type> interceptedClasses = null)
        {
            var target = provider.GetService(type);
            if (interceptedClasses.IsNullOrEmpty())
            {
                return target;
            }

            var proxy = provider.GetService<IProxyGenerator>();
            var interClassServices = new List<IInterceptor>(interceptedClasses.Count);
            foreach (var interClass in interceptedClasses)
            {
                var interIns = provider.GetService(interClass);
                if (interIns == null)
                {
                    continue;
                }

                interClassServices.Add(interIns as IInterceptor);
            }

            if (interClassServices.Count == 0)
            {
                return target;
            }
            else
            {
                // 选择最多参数的构造器
                var con = type.GetConstructors().OrderByDescending(p => p.GetParameters().Length).Take(1).First();
                var parames = con.GetParameters();
                if (parames.IsNullOrEmpty())
                {
                    return proxy.CreateClassProxy(type, interClassServices.ToArray());
                }

                // 构造器参数值数组
                var conValues = new object[parames.Length];
                for (var i = 0; i < parames.Length; i++)
                {
                    conValues[i] = provider.GetService(parames[i].ParameterType);
                }

                return proxy.CreateClassProxy(type, conValues, interClassServices.ToArray());
            }
        }

        /// <summary>
        /// 从服务提供者获取代理实例
        /// </summary>
        /// <param name="provider">服务提供者</param>
        /// <param name="interceptedClasses">拦截器类型字典集合</param>
        /// <returns>代理实例</returns>
        public static T GetProxyInstanceFromProvider<T>(this IServiceProvider provider, ICollection<Type> interceptedClasses = null) where T : class
        {
            return provider.GetProxyInstanceFromProvider(typeof(T), interceptedClasses) as T;
        }

        /// <summary>
        /// 添加类型映射生命周期
        /// </summary>
        /// <param name="service">服务收藏</param>
        /// <param name="typeMapLifetimes">映射生命周期字典</param>
        /// <returns>服务收藏</returns>
        private static IServiceCollection AddTypeMapLifetimes(this IServiceCollection service, IDictionary<Type, ServiceLifetime> typeMapLifetimes)
        {
            if (typeMapLifetimes.IsNullOrEmpty())
            {
                return service;
            }

            foreach (var interClass in typeMapLifetimes)
            {
                switch (interClass.Value)
                {
                    case ServiceLifetime.Transient:
                        service.AddTransient(interClass.Key);

                        break;

                    case ServiceLifetime.Scoped:
                        service.AddScoped(interClass.Key);

                        break;

                    case ServiceLifetime.Singleton:
                        service.AddSingleton(interClass.Key);

                        break;

                    default:
                        throw new NotSupportedException($"不支持的生命周期:{interClass.Value}");
                }
            }

            return service;
        }
    }
}
