# 前端开发接入 gRPC-Web 实时推送指南

## 概述

本指南面向前端开发人员，说明如何接入后端提供的 gRPC 实时推送服务。

## 前置条件

### 工具安装
1. **Protocol Buffers 编译器 (protoc)**
   - 下载：https://github.com/protocolbuffers/protobuf/releases
   - 添加到系统 PATH

2. **gRPC-Web 插件**
   ```bash
   npm install -g grpc-web
   ```

### 从后端获取的文件
- `.proto` 文件：定义服务接口和数据结构
- 服务端地址和端口信息
- CORS 配置确认

## 接入步骤

### 第一步：分析 Proto 文件

获取后端的 `.proto` 文件，分析服务定义：

```protobuf
syntax = "proto3";
package chat;

// 服务定义
service ChatService {
  rpc StartRealtimePush(RealtimePushRequest) returns (stream RealtimePushResponse);
}

// 请求消息
message RealtimePushRequest {
  string client_id = 1;
  int64 timestamp = 2;
}

// 响应消息
message RealtimePushResponse {
  string data = 1;
  int64 timestamp = 2;
  string data_type = 3;
}
```

关键信息：
- **服务名**：`ChatService`
- **方法名**：`StartRealtimePush`
- **请求类型**：`RealtimePushRequest`
- **响应类型**：`stream RealtimePushResponse`（流式响应）

### 第二步：生成客户端代码

#### 2.1 创建生成脚本

创建 `generate-client.ps1`：

```powershell
# 创建输出目录
$generatedDir = "client\generated"
if (!(Test-Path $generatedDir)) {
    New-Item -ItemType Directory -Path $generatedDir -Force
}

# 生成 JavaScript 代码
protoc -I=. `
  --js_out=import_style=commonjs:client\generated `
  --grpc-web_out=import_style=commonjs,mode=grpcwebtext:client\generated `
  chat.proto
```

#### 2.2 执行生成

```bash
.\generate-client.ps1
```

生成的文件：
- `chat_pb.js` - 消息类定义
- `chat_grpc_web_pb.js` - 服务客户端

### 第三步：浏览器适配

生成的代码是 CommonJS 格式，需要适配浏览器环境。

#### 3.1 适配消息类 (`chat_pb_browser.js`)

```javascript
(function() {
    'use strict';
    
    // 确保命名空间存在
    if (!window.proto) window.proto = {};
    if (!window.proto.chat) window.proto.chat = {};
    
    // 请求消息类
    window.proto.chat.RealtimePushRequest = function(opt_data) {
        jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    
    // 继承 jspb.Message
    window.proto.chat.RealtimePushRequest.prototype = Object.create(jspb.Message.prototype);
    window.proto.chat.RealtimePushRequest.prototype.constructor = window.proto.chat.RealtimePushRequest;
    
    // Getter/Setter 方法
    window.proto.chat.RealtimePushRequest.prototype.getClientId = function() {
        return jspb.Message.getFieldWithDefault(this, 1, "");
    };
    
    window.proto.chat.RealtimePushRequest.prototype.setClientId = function(value) {
        return jspb.Message.setProto3StringField(this, 1, value);
    };
    
    // ... 其他字段的 getter/setter
    
    // 序列化方法
    window.proto.chat.RealtimePushRequest.prototype.serializeBinary = function() {
        const writer = new jspb.BinaryWriter();
        window.proto.chat.RealtimePushRequest.serializeBinaryToWriter(this, writer);
        return writer.getResultBuffer();
    };
    
    // 响应消息类（类似结构）
    window.proto.chat.RealtimePushResponse = function(opt_data) {
        jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    
    // ... 响应类的方法定义
})();
```

#### 3.2 适配服务客户端 (`chat_grpc_web_pb_browser.js`)

```javascript
(function() {
    'use strict';
    
    // 服务客户端类
    window.proto.chat.ChatServiceClient = function(hostname, credentials, options) {
        if (!options) options = {};
        options['format'] = options['format'] || 'text';
        
        // 使用 gRPC-Web 基类
        window.grpc.web.GrpcWebClientBase.call(this, options);
        
        this.hostname_ = hostname;
        this.credentials_ = credentials;
        this.options_ = options;
    };
    
    // 继承基类
    window.proto.chat.ChatServiceClient.prototype = Object.create(window.grpc.web.GrpcWebClientBase.prototype);
    
    // 方法描述符
    const methodDescriptor = new window.grpc.web.MethodDescriptor(
        '/chat.ChatService/StartRealtimePush',
        window.grpc.web.MethodType.SERVER_STREAMING,
        window.proto.chat.RealtimePushRequest,
        window.proto.chat.RealtimePushResponse,
        function(request) { return request.serializeBinary(); },
        function(bytes) { return window.proto.chat.RealtimePushResponse.deserializeBinary(bytes); }
    );
    
    // 服务方法
    window.proto.chat.ChatServiceClient.prototype.startRealtimePush = function(request, metadata) {
        const url = this.hostname_ + '/chat.ChatService/StartRealtimePush';
        return this.serverStreaming(url, request, metadata || {}, methodDescriptor);
    };
})();
```

### 第四步：实现 gRPC-Web 兼容层

创建 `grpc-web-shim.js` 处理底层通信：

```javascript
(function() {
    'use strict';
    
    // 创建 gRPC 命名空间
    if (!window.grpc) window.grpc = {};
    if (!window.grpc.web) window.grpc.web = {};
    
    // 方法类型枚举
    window.grpc.web.MethodType = {
        UNARY: 'unary',
        SERVER_STREAMING: 'server_streaming'
    };
    
    // 基础客户端类
    window.grpc.web.GrpcWebClientBase = function(options) {
        this.options = options || {};
        this.format = this.options.format || 'text';
    };
    
    // 流式调用方法
    window.grpc.web.GrpcWebClientBase.prototype.serverStreaming = function(url, request, metadata, methodDescriptor) {
        // 实现流式调用逻辑
        // 包括：请求序列化、HTTP 调用、响应解析、流事件处理
    };
})();
```

### 第五步：实现业务逻辑

创建主要的客户端逻辑 (`client.js`)：

```javascript
class RealtimePushClient {
    constructor() {
        this.client = null;
        this.isConnected = false;
        this.serverUrl = 'https://your-server:port';
        this.currentStream = null;
        
        this.initializeUI();
    }
    
    connect() {
        try {
            // 创建 gRPC 客户端
            this.client = new proto.chat.ChatServiceClient(this.serverUrl);
            this.isConnected = true;
            console.log('连接成功');
        } catch (error) {
            console.error('连接失败:', error);
        }
    }
    
    startRealtimePush() {
        if (!this.isConnected || !this.client) {
            console.error('未连接到服务器');
            return;
        }
        
        // 创建请求
        const request = new proto.chat.RealtimePushRequest();
        request.setClientId('web-client-' + Date.now());
        request.setTimestamp(Math.floor(Date.now() / 1000));
        
        // 启动流式推送
        const stream = this.client.startRealtimePush(request, {});
        this.currentStream = stream;
        
        // 处理数据
        stream.on('data', (response) => {
            this.handleRealtimeData(response);
        });
        
        // 处理错误
        stream.on('error', (error) => {
            console.error('推送错误:', error);
        });
        
        // 处理结束
        stream.on('end', () => {
            console.log('推送结束');
            this.currentStream = null;
        });
    }
    
    handleRealtimeData(response) {
        const data = response.getData();
        const dataType = response.getDataType();
        const timestamp = response.getTimestamp();
        
        console.log('收到数据:', { data, dataType, timestamp });
        
        // 更新 UI
        this.displayMessage(dataType, data);
    }
    
    displayMessage(type, content) {
        // 实现 UI 更新逻辑
    }
}

// 初始化
document.addEventListener('DOMContentLoaded', () => {
    window.realtimePushClient = new RealtimePushClient();
});
```

### 第六步：HTML 集成

创建 `index.html`：

```html
<!DOCTYPE html>
<html>
<head>
    <title>实时推送客户端</title>
</head>
<body>
    <div id="status">状态: 未连接</div>
    <div id="messages"></div>
    <button id="startBtn">启动推送</button>
    <button id="stopBtn">停止推送</button>
    
    <!-- 依赖库 -->
    <script src="https://unpkg.com/google-protobuf@3.21.2/google-protobuf.js"></script>
    
    <!-- 生成的代码 -->
    <script src="./grpc-web-shim.js"></script>
    <script src="./generated/chat_pb_browser.js"></script>
    <script src="./generated/chat_grpc_web_pb_browser.js"></script>
    
    <!-- 业务逻辑 -->
    <script src="./client.js"></script>
</body>
</html>
```

## 调试和测试

### 1. 检查连接
```javascript
// 在浏览器控制台测试
const client = new proto.chat.ChatServiceClient('https://your-server:port');
console.log('客户端创建成功:', client);
```

### 2. 测试消息创建
```javascript
const request = new proto.chat.RealtimePushRequest();
request.setClientId('test');
console.log('请求创建成功:', request.getClientId());
```

### 3. 网络调试
- 打开浏览器开发者工具
- 查看 Network 标签页
- 监控 gRPC 请求和响应

## 常见问题

### 1. CORS 错误
确保后端配置了正确的 CORS 策略：
```csharp
app.UseCors(policy => policy
    .AllowAnyOrigin()
    .AllowAnyMethod()
    .AllowAnyHeader()
    .WithExposedHeaders("Grpc-Status", "Grpc-Message", "Grpc-Encoding", "Grpc-Accept-Encoding"));
```

### 2. 协议不匹配
确保使用正确的协议：
- 开发环境：可以使用 HTTP
- 生产环境：建议使用 HTTPS

### 3. 代码生成失败
检查：
- protoc 是否正确安装
- .proto 文件语法是否正确
- 路径是否正确

## 最佳实践

1. **错误处理**：实现完善的错误处理和重连机制
2. **性能优化**：合理控制推送频率和数据量
3. **用户体验**：提供清晰的状态提示和加载指示
4. **安全性**：使用 HTTPS 和适当的认证机制
5. **兼容性**：测试不同浏览器的兼容性

## 总结

通过以上步骤，前端开发人员可以成功接入后端的 gRPC 实时推送服务。关键是理解 Protocol Buffers 定义、正确生成和适配客户端代码，以及实现合适的业务逻辑。